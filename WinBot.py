import discord
from discord import app_commands
from discord.ext import commands
import asyncio
import os
import platform
import subprocess
import time
import json
import pyautogui
import webbrowser
import psutil
import ctypes
import socket
import shutil
import screen_brightness_control as sbc
import pygetwindow as gw
import pycaw.pycaw as pycaw
from ctypes import cast, POINTER
from comtypes import CLSCTX_ALL
from discord.app_commands import Choice

# Konfiguracja
def load_config():
    try:
        with open('config.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {"token": "TW√ìJ_TOKEN_BOTA", "admin_ids": [], "allowed_roles": ["Admin"]}

config = load_config()

# Bot TYLKO do slash commands - bez prefixu!
intents = discord.Intents.default()
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

def is_admin(interaction):
    return (interaction.user.id in config.get("admin_ids", []) or 
            any(role.name in config.get("allowed_roles", []) for role in interaction.user.roles))

@bot.event
async def on_ready():
    print(f'‚úÖ Zalogowano jako {bot.user.name}')
    
    # Synchronizacja slash commands
    try:
        synced = await bot.tree.sync()
        print(f'‚úÖ Zsynchronizowano {len(synced)} slash commands:')
        for cmd in synced:
            print(f'   ‚û§ /{cmd.name}')
    except Exception as e:
        print(f'‚ùå B≈ÇƒÖd synchronizacji: {e}')

# ========== üéÆ PODSTAWOWE KOMENDY ==========
@bot.tree.command(name="pomoc", description="Wy≈õwietla wszystkie komendy")
async def pomoc(interaction: discord.Interaction):
    if not is_admin(interaction):
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    embed = discord.Embed(title="‚ö° FSOCIETY CONTROL PANEL", color=0x00ff00)
    embed.description = "**Dostƒôpne komendy:**\n\n"
    
    embed.add_field(name="üîß System", 
                   value="‚Ä¢ `/shutdown` - Wy≈ÇƒÖcza komputer\n‚Ä¢ `/restart` - Restartuje komputer\n‚Ä¢ `/lock` - Blokuje komputer\n‚Ä¢ `/systeminfo` - Informacje o systemie\n‚Ä¢ `/tasklist` - Lista proces√≥w\n‚Ä¢ `/killprocess` - Zako≈Ñcz proces", 
                   inline=False)
    
    embed.add_field(name="üñ•Ô∏è Kontrola", 
                   value="‚Ä¢ `/screenshot` - Zr√≥b zrzut ekranu\n‚Ä¢ `/volume` - Kontrola g≈Ço≈õno≈õci\n‚Ä¢ `/brightness` - Kontrola jasno≈õci\n‚Ä¢ `/window` - ZarzƒÖdzanie oknami\n‚Ä¢ `/type` - Wpisuje tekst\n‚Ä¢ `/click` - Symuluj klikniƒôcie", 
                   inline=False)
    
    embed.add_field(name="üåê Sieƒá", 
                   value="‚Ä¢ `/ipconfig` - Informacje o sieci\n‚Ä¢ `/ping` - Test po≈ÇƒÖczenia\n‚Ä¢ `/portscan` - Skanowanie port√≥w\n‚Ä¢ `/download` - Pobierz plik", 
                   inline=False)
    
    embed.add_field(name="üìÅ Pliki", 
                   value="‚Ä¢ `/explorer` - Otw√≥rz eksplorator\n‚Ä¢ `/dir` - Lista plik√≥w\n‚Ä¢ `/readfile` - Czytaj plik\n‚Ä¢ `/delete` - Usu≈Ñ plik\n‚Ä¢ `/execute` - Uruchom plik", 
                   inline=False)
    
    embed.add_field(name="‚öôÔ∏è UrzƒÖdzenia", 
                   value="‚Ä¢ `/usb` - Kontrola USB\n‚Ä¢ `/bluetooth` - Kontrola Bluetooth\n‚Ä¢ `/wifi` - ZarzƒÖdzanie WiFi", 
                   inline=False)
    
    embed.add_field(name="üéÆ Inne", 
                   value="‚Ä¢ `/ptoszek` - Automatyzacja ptoszek.pl\n‚Ä¢ `/cmd` - Wykonuje komendƒô\n‚Ä¢ `/sync` - Synchronizuje komendy", 
                   inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="shutdown", description="Wy≈ÇƒÖcza komputer")
@app_commands.describe(potwierdzenie="Potwierd≈∫ 'tak'")
async def shutdown(interaction: discord.Interaction, potwierdzenie: str = "nie"):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    if potwierdzenie != "tak":
        await interaction.response.send_message("‚ö†Ô∏è Wpisz: `/shutdown potwierdzenie: tak`")
        return
        
    await interaction.response.send_message("üî¥ Wy≈ÇƒÖczanie...")
    os.system("shutdown /s /f /t 0")

@bot.tree.command(name="restart", description="Restartuje komputer")
@app_commands.describe(potwierdzenie="Potwierd≈∫ 'tak'")
async def restart(interaction: discord.Interaction, potwierdzenie: str = "nie"):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    if potwierdzenie != "tak":
        await interaction.response.send_message("‚ö†Ô∏è Wpisz: `/restart potwierdzenie: tak`")
        return
        
    await interaction.response.send_message("üîÑ Restartowanie...")
    os.system("shutdown /r /f /t 0")

@bot.tree.command(name="lock", description="Blokuje komputer")
async def lock(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    await interaction.response.send_message("üîí Blokowanie...")
    os.system("rundll32.exe user32.dll,LockWorkStation")

@bot.tree.command(name="usb", description="Kontrola USB")
@app_commands.describe(akcja="Wybierz akcjƒô", czas="Czas w sekundach (tylko dla disable)")
@app_commands.choices(akcja=[
    Choice(name="disable", value="disable"),
    Choice(name="enable", value="enable"),
    Choice(name="list", value="list")
])
async def usb(interaction: discord.Interaction, akcja: str, czas: int = 5):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if akcja == "disable":
            await interaction.response.send_message(f"üîå Wy≈ÇƒÖczam USB na {czas}s...")
            result = subprocess.run('pnputil /disable-device "USB\\ROOT_HUB30\\4&2e4d5c8c&0"', shell=True, capture_output=True, text=True)
            await asyncio.sleep(czas)
            subprocess.run('pnputil /enable-device "USB\\ROOT_HUB30\\4&2e4d5c8c&0"', shell=True)
            await interaction.followup.send("‚úÖ USB w≈ÇƒÖczone ponownie")
            
        elif akcja == "enable":
            await interaction.response.send_message("üîå W≈ÇƒÖczam USB...")
            result = subprocess.run('pnputil /enable-device "USB\\ROOT_HUB30\\4&2e4d5c8c&0"', shell=True, capture_output=True, text=True)
            await interaction.followup.send("‚úÖ USB w≈ÇƒÖczone")
            
        elif akcja == "list":
            await interaction.response.send_message("üìã Lista urzƒÖdze≈Ñ USB...")
            result = subprocess.run('pnputil /enum-devices /connected /class "USB"', shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            if len(output) > 1500:
                output = output[:1500] + "..."
            await interaction.followup.send(f"```{output}```")
            
    except Exception as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="type", description="Wpisuje tekst")
@app_commands.describe(tekst="Tekst do wpisania")
async def type_text(interaction: discord.Interaction, tekst: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    pyautogui.write(tekst)
    await interaction.response.send_message(f"‚å®Ô∏è Wpisano: {tekst}")

@bot.tree.command(name="ptoszek", description="Automatyzacja ptoszek.pl")
async def ptoszek(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    await interaction.response.send_message("üåê Uruchamiam ptoszek.pl...")
    try:
        webbrowser.open("https://ptoszek.pl")
        await asyncio.sleep(3)
        for _ in range(3):
            pyautogui.press('space')
            await asyncio.sleep(0.5)
        await interaction.followup.send("‚úÖ Automatyzacja zako≈Ñczona!")
    except Exception as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="tasklist", description="Lista proces√≥w")
async def tasklist(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    processes = []
    for proc in psutil.process_iter(['name', 'pid', 'memory_info']):
        try: 
            memory_mb = proc.info['memory_info'].rss / 1024 / 1024
            processes.append(f"{proc.info['name']} (PID: {proc.info['pid']}, RAM: {memory_mb:.1f}MB)")
        except: 
            continue
    
    # Sort by memory usage
    processes.sort(key=lambda x: float(x.split("RAM: ")[1].replace("MB", "")), reverse=True)
    
    process_list = "\n".join(processes[:15])
    await interaction.response.send_message(f"üìã Top 15 proces√≥w:\n```{process_list}```")

@bot.tree.command(name="killprocess", description="Zako≈Ñcz proces")
@app_commands.describe(pid="ID procesu do zako≈Ñczenia")
async def killprocess(interaction: discord.Interaction, pid: int):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        process = psutil.Process(pid)
        process_name = process.name()
        process.terminate()
        await interaction.response.send_message(f"‚úÖ Zako≈Ñczono proces: {process_name} (PID: {pid})")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="cmd", description="Wykonuje komendƒô CMD")
@app_commands.describe(komenda="Komenda do wykonania")
async def cmd(interaction: discord.Interaction, komenda: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        result = subprocess.run(komenda, shell=True, capture_output=True, text=True, timeout=15)
        output = result.stdout if result.stdout else result.stderr
        if len(output) > 1500: 
            output = output[:1500] + "..."
        await interaction.response.send_message(f"üíª Wynik:\n```{output}```")
    except subprocess.TimeoutExpired:
        await interaction.response.send_message("‚ùå Komenda przekroczy≈Ça limit czasu (15s)")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="screenshot", description="Robienie zrzutu ekranu")
async def screenshot(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        screenshot = pyautogui.screenshot()
        screenshot_path = "screenshot.png"
        screenshot.save(screenshot_path)
        
        await interaction.response.send_message("üì∏ Zrzut ekranu:", file=discord.File(screenshot_path))
        
        # Usu≈Ñ plik po wys≈Çaniu
        os.remove(screenshot_path)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="systeminfo", description="Informacje o systemie")
async def systeminfo(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        # Pobierz informacje o systemie
        system_info = f"""
        üñ•Ô∏è **System Information**
        ‚Ä¢ System: {platform.system()} {platform.release()}
        ‚Ä¢ Wersja: {platform.version()}
        ‚Ä¢ Architektura: {platform.architecture()[0]}
        ‚Ä¢ Procesor: {platform.processor()}
        ‚Ä¢ Hostname: {socket.gethostname()}
        ‚Ä¢ IP: {socket.gethostbyname(socket.gethostname())}
        
        üíæ **Pamiƒôƒá**
        ‚Ä¢ RAM: {psutil.virtual_memory().total / (1024**3):.1f} GB
        ‚Ä¢ Dostƒôpna RAM: {psutil.virtual_memory().available / (1024**3):.1f} GB
        ‚Ä¢ U≈ºycie RAM: {psutil.virtual_memory().percent}%
        
        üíø **Dyski**
        """
        
        # Informacje o dyskach
        partitions = psutil.disk_partitions()
        for partition in partitions:
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                system_info += f"‚Ä¢ {partition.device}: {usage.total / (1024**3):.1f} GB ({usage.percent}% u≈ºyte)\n"
            except:
                continue
        
        await interaction.response.send_message(system_info)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="ipconfig", description="Informacje o sieci")
async def ipconfig(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        result = subprocess.run('ipconfig /all', shell=True, capture_output=True, text=True)
        output = result.stdout if result.stdout else result.stderr
        if len(output) > 1500:
            output = output[:1500] + "..."
        await interaction.response.send_message(f"üåê Informacje sieciowe:\n```{output}```")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="ping", description="Test po≈ÇƒÖczenia")
@app_commands.describe(host="Host do pingowania")
async def ping(interaction: discord.Interaction, host: str = "google.com"):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        result = subprocess.run(f'ping {host}', shell=True, capture_output=True, text=True)
        output = result.stdout if result.stdout else result.stderr
        if len(output) > 1500:
            output = output[:1500] + "..."
        await interaction.response.send_message(f"üì∂ Ping {host}:\n```{output}```")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="volume", description="Kontrola g≈Ço≈õno≈õci")
@app_commands.describe(poziom="Poziom g≈Ço≈õno≈õci (0-100)")
async def volume(interaction: discord.Interaction, poziom: int):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if not 0 <= poziom <= 100:
            await interaction.response.send_message("‚ùå Poziom g≈Ço≈õno≈õci musi byƒá miƒôdzy 0 a 100")
            return
            
        # Ustaw g≈Ço≈õno≈õƒá systemowƒÖ
        from ctypes import cast, POINTER
        from comtypes import CLSCTX_ALL
        from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
        
        devices = AudioUtilities.GetSpeakers()
        interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
        volume = cast(interface, POINTER(IAudioEndpointVolume))
        volume.SetMasterVolumeLevelScalar(poziom/100, None)
        
        await interaction.response.send_message(f"üîä Ustawiono g≈Ço≈õno≈õƒá na {poziom}%")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="brightness", description="Kontrola jasno≈õci ekranu")
@app_commands.describe(poziom="Poziom jasno≈õci (0-100)")
async def brightness(interaction: discord.Interaction, poziom: int):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if not 0 <= poziom <= 100:
            await interaction.response.send_message("‚ùå Poziom jasno≈õci musi byƒá miƒôdzy 0 a 100")
            return
            
        sbc.set_brightness(poziom)
        await interaction.response.send_message(f"üí° Ustawiono jasno≈õƒá na {poziom}%")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="window", description="ZarzƒÖdzanie oknami")
@app_commands.describe(akcja="Wybierz akcjƒô", tytul="Tytu≈Ç okna (dla focus/close)")
@app_commands.choices(akcja=[
    Choice(name="list", value="list"),
    Choice(name="focus", value="focus"),
    Choice(name="close", value="close"),
    Choice(name="minimize", value="minimize"),
    Choice(name="maximize", value="maximize")
])
async def window(interaction: discord.Interaction, akcja: str, tytul: str = ""):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if akcja == "list":
            windows = gw.getAllTitles()
            window_list = "\n".join([f"‚Ä¢ {title}" for title in windows if title])
            if len(window_list) > 1500:
                window_list = window_list[:1500] + "..."
            await interaction.response.send_message(f"üìã Aktywne okna:\n```{window_list}```")
            
        elif akcja == "focus" and tytul:
            target_window = gw.getWindowsWithTitle(tytul)
            if target_window:
                target_window[0].activate()
                await interaction.response.send_message(f"üéØ Aktywowano okno: {tytul}")
            else:
                await interaction.response.send_message(f"‚ùå Nie znaleziono okna: {tytul}")
                
        elif akcja == "close" and tytul:
            target_window = gw.getWindowsWithTitle(tytul)
            if target_window:
                target_window[0].close()
                await interaction.response.send_message(f"‚ùå Zamkniƒôto okno: {tytul}")
            else:
                await interaction.response.send_message(f"‚ùå Nie znaleziono okna: {tytul}")
                
        elif akcja == "minimize" and tytul:
            target_window = gw.getWindowsWithTitle(tytul)
            if target_window:
                target_window[0].minimize()
                await interaction.response.send_message(f"üìã Zminimalizowano okno: {tytul}")
            else:
                await interaction.response.send_message(f"‚ùå Nie znaleziono okna: {tytul}")
                
        elif akcja == "maximize" and tytul:
            target_window = gw.getWindowsWithTitle(tytul)
            if target_window:
                target_window[0].maximize()
                await interaction.response.send_message(f"üìã Maksymalizowano okno: {tytul}")
            else:
                await interaction.response.send_message(f"‚ùå Nie znaleziono okna: {tytul}")
                
        else:
            await interaction.response.send_message("‚ùå Nieprawid≈Çowa akcja lub brak tytu≈Çu")
            
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="click", description="Symuluj klikniƒôcie myszƒÖ")
@app_commands.describe(button="Przycisk myszy", x="Pozycja X", y="Pozycja Y")
@app_commands.choices(button=[
    Choice(name="left", value="left"),
    Choice(name="right", value="right"),
    Choice(name="middle", value="middle")
])
async def click(interaction: discord.Interaction, button: str, x: int = None, y: int = None):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if x is not None and y is not None:
            pyautogui.click(x, y, button=button)
            await interaction.response.send_message(f"üñ±Ô∏è Klikniƒôto {button} na pozycji ({x}, {y})")
        else:
            pyautogui.click(button=button)
            await interaction.response.send_message(f"üñ±Ô∏è Klikniƒôto {button} na aktualnej pozycji")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="dir", description="Lista plik√≥w w katalogu")
@app_commands.describe(sciezka="≈öcie≈ºka katalogu")
async def dir(interaction: discord.Interaction, sciezka: str = "."):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        files = os.listdir(sciezka)
        file_list = "\n".join([f"‚Ä¢ {f}" for f in files])
        if len(file_list) > 1500:
            file_list = file_list[:1500] + "..."
        await interaction.response.send_message(f"üìÅ Pliki w {sciezka}:\n```{file_list}```")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="readfile", description="Czytaj zawarto≈õƒá pliku")
@app_commands.describe(sciezka="≈öcie≈ºka do pliku")
async def readfile(interaction: discord.Interaction, sciezka: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if not os.path.exists(sciezka):
            await interaction.response.send_message("‚ùå Plik nie istnieje!")
            return
            
        with open(sciezka, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            
        if len(content) > 1500:
            content = content[:1500] + "..."
            
        await interaction.response.send_message(f"üìÑ Zawarto≈õƒá {sciezka}:\n```{content}```")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="delete", description="Usu≈Ñ plik lub folder")
@app_commands.describe(sciezka="≈öcie≈ºka do pliku/folderu")
async def delete(interaction: discord.Interaction, sciezka: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if not os.path.exists(sciezka):
            await interaction.response.send_message("‚ùå Plik/folder nie istnieje!")
            return
            
        if os.path.isfile(sciezka):
            os.remove(sciezka)
            await interaction.response.send_message(f"üóëÔ∏è Usuniƒôto plik: {sciezka}")
        else:
            shutil.rmtree(sciezka)
            await interaction.response.send_message(f"üóëÔ∏è Usuniƒôto folder: {sciezka}")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="execute", description="Uruchom plik")
@app_commands.describe(sciezka="≈öcie≈ºka do pliku")
async def execute(interaction: discord.Interaction, sciezka: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if not os.path.exists(sciezka):
            await interaction.response.send_message("‚ùå Plik nie istnieje!")
            return
            
        os.startfile(sciezka)
        await interaction.response.send_message(f"üöÄ Uruchomiono: {sciezka}")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="explorer", description="Otw√≥rz Eksplorator Plik√≥w")
@app_commands.describe(sciezka="≈öcie≈ºka do otwarcia")
async def explorer(interaction: discord.Interaction, sciezka: str = ""):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if sciezka and not os.path.exists(sciezka):
            await interaction.response.send_message("‚ùå ≈öcie≈ºka nie istnieje!")
            return
            
        if sciezka:
            os.startfile(sciezka)
            await interaction.response.send_message(f"üìÇ Otworzono: {sciezka}")
        else:
            os.system("explorer")
            await interaction.response.send_message("üìÇ Otworzono Eksplorator Plik√≥w")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="download", description="Pobierz plik z URL")
@app_commands.describe(url="URL do pobrania", sciezka="≈öcie≈ºka zapisu (opcjonalnie)")
async def download(interaction: discord.Interaction, url: str, sciezka: str = ""):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        import requests
        from urllib.parse import urlparse
        
        await interaction.response.send_message(f"üì• Pobieranie: {url}")
        
        # Pobierz nazwƒô pliku z URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        if not filename:
            filename = "downloaded_file"
            
        # Ustaw ≈õcie≈ºkƒô zapisu
        if not sciezka:
            sciezka = filename
        elif os.path.isdir(sciezka):
            sciezka = os.path.join(sciezka, filename)
            
        # Pobierz plik
        response = requests.get(url, stream=True)
        response.raise_for_status()
        
        with open(sciezka, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
                
        await interaction.followup.send(f"‚úÖ Pobrano: {sciezka}")
    except Exception as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd pobierania: {e}")

@bot.tree.command(name="bluetooth", description="Kontrola Bluetooth")
@app_commands.describe(akcja="Wybierz akcjƒô")
@app_commands.choices(akcja=[
    Choice(name="on", value="on"),
    Choice(name="off", value="off"),
    Choice(name="discoverable", value="discoverable")
])
async def bluetooth(interaction: discord.Interaction, akcja: str):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if akcja == "on":
            subprocess.run('powershell -command "Start-Process bluetoothsettings:"', shell=True)
            await interaction.response.send_message("üì± W≈ÇƒÖczono Bluetooth")
        elif akcja == "off":
            subprocess.run('powershell -command "Get-PnpDevice -Class Bluetooth | Disable-PnpDevice -Confirm:$false"', shell=True)
            await interaction.response.send_message("üì± Wy≈ÇƒÖczono Bluetooth")
        elif akcja == "discoverable":
            subprocess.run('powershell -command "Start-Process ms-settings:bluetooth"', shell=True)
            await interaction.response.send_message("üì± Ustawiono tryb wykrywalno≈õci Bluetooth")
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="wifi", description="ZarzƒÖdzanie WiFi")
@app_commands.describe(akcja="Wybierz akcjƒô", nazwa="Nazwa sieci (dla connect)")
@app_commands.choices(akcja=[
    Choice(name="list", value="list"),
    Choice(name="connect", value="connect"),
    Choice(name="disconnect", value="disconnect"),
    Choice(name="on", value="on"),
    Choice(name="off", value="off")
])
async def wifi(interaction: discord.Interaction, akcja: str, nazwa: str = ""):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        if akcja == "list":
            result = subprocess.run('netsh wlan show profiles', shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            if len(output) > 1500:
                output = output[:1500] + "..."
            await interaction.response.send_message(f"üì∂ Profile WiFi:\n```{output}```")
            
        elif akcja == "connect" and nazwa:
            result = subprocess.run(f'netsh wlan connect name="{nazwa}"', shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            await interaction.response.send_message(f"üì∂ ≈ÅƒÖczenie z {nazwa}:\n```{output}```")
            
        elif akcja == "disconnect":
            result = subprocess.run('netsh wlan disconnect', shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            await interaction.response.send_message(f"üì∂ Roz≈ÇƒÖczono WiFi:\n```{output}```")
            
        elif akcja == "on":
            result = subprocess.run('netsh interface set interface "Wi-Fi" enabled', shell=True, capture_output=True, text=True)
            await interaction.response.send_message("üì∂ W≈ÇƒÖczono WiFi")
            
        elif akcja == "off":
            result = subprocess.run('netsh interface set interface "Wi-Fi" disabled', shell=True, capture_output=True, text=True)
            await interaction.response.send_message("üì∂ Wy≈ÇƒÖczono WiFi")
            
        else:
            await interaction.response.send_message("‚ùå Nieprawid≈Çowa akcja lub brak nazwy sieci")
            
    except Exception as e:
        await interaction.response.send_message(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="portscan", description="Skanowanie port√≥w")
@app_commands.describe(host="Host do skanowania", porty="Zakres port√≥w (np. 80-443)")
async def portscan(interaction: discord.Interaction, host: str = "localhost", porty: str = "1-1000"):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    try:
        await interaction.response.send_message(f"üîç Skanowanie {host} porty {porty}...")
        
        start_port, end_port = map(int, porty.split('-'))
        open_ports = []
        
        for port in range(start_port, end_port + 1):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.1)
            result = sock.connect_ex((host, port))
            if result == 0:
                open_ports.append(port)
            sock.close()
            
        if open_ports:
            await interaction.followup.send(f"‚úÖ Otwarte porty na {host}: {', '.join(map(str, open_ports))}")
        else:
            await interaction.followup.send(f"‚ùå Brak otwartych port√≥w w zakresie {porty}")
    except Exception as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd: {e}")

@bot.tree.command(name="sync", description="Synchronizuje komendy")
async def sync(interaction: discord.Interaction):
    if not is_admin(interaction): 
        await interaction.response.send_message("‚ùå Brak uprawnie≈Ñ!", ephemeral=True)
        return
        
    await interaction.response.send_message("üîÑ Synchronizacja...")
    try:
        synced = await bot.tree.sync()
        await interaction.followup.send(f"‚úÖ Zsynchronizowano {len(synced)} komend!")
    except Exception as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd: {e}")

# URUCHOMIENIE
if __name__ == "__main__":
    # Sprawd≈∫ wymagane biblioteki
    try:
        import screen_brightness_control
        import pygetwindow
        import requests
    except ImportError as e:
        print(f"‚ùå Brak wymaganej biblioteki: {e}")
        print("üì¶ Zainstaluj brakujƒÖce biblioteki:")
        print("pip install screen-brightness-control pygetwindow pycaw requests")
        exit(1)
    
    if config.get("token") and config["token"] != "TW√ìJ_TOKEN_BOTA":
        try:
            bot.run(config["token"])
        except discord.LoginFailure:
            print("‚ùå B≈ÇƒÖd logowania - sprawd≈∫ token!")
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd: {e}")
    else:
        print("‚ùå Brak tokenu w config.json!")